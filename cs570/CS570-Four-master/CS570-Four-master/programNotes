************************DUP2********************************************
Standard C Library Functions                             dup2(3C)



NAME
     dup2 - duplicate an open file descriptor

SYNOPSIS
     #include <unistd.h>

     int dup2(int fildes, int fildes2);

DESCRIPTION
     The dup2() function causes the file  descriptor  fildes2  to
     refer  to  the same file as fildes. The fildes argument is a
     file descriptor referring to an open file, and fildes2 is  a
     non-negative  integer  less  than  the current value for the
     maximum number of open file descriptors  allowed the calling
     process.   See getrlimit(2). If fildes2 already refers to an
     open file, not fildes, it is closed first. If fildes2 refers
     to fildes, or if fildes is not a valid open file descriptor,
     fildes2 will not be closed first.

RETURN VALUES
     Upon successful completion a non-negative integer represent-
     ing  the  file  descriptor  is  returned.  Otherwise,  -1 is
     returned and errno is set to indicate the error.


************************EXECVP******************************************
System Calls                                              exec(2)



NAME
     exec, execl, execle, execlp, execv, execve, execvp - execute
     a file

SYNOPSIS
     #include <unistd.h>     
     int execvp(const char *file, char *const argv[]);


DESCRIPTION
     Each of the  functions  in  the  exec  family  replaces  the
     current  process  image  with  a  new process image. The new
     image is constructed from a regular, executable file  called
     the  new  process image file. This file is either an execut-
     able object file or a file of data for an interpreter. There
     is  no  return  from a successful call to one of these func-
     tions because the calling process image is overlaid  by  the
     new process image.

RETURN VALUES
     If a function in the exec family returns to the calling pro-
     cess  image,  an  error has occurred; the return value is -1
     and errno is set to indicate the error.


USAGE
     As the state of conversion descriptors and message catalogue
     descriptors  in the new process image is undefined, portable
     applications should not rely on their use and  should  close
     them prior to calling one of the exec functions.


     Applications that  require  other  than  the  default  POSIX
     locale should call setlocale(3C) with the appropriate param-
     eters to establish the locale of the new process.


     The environ array should not be  accessed  directly  by  the
     application.

*****************************CHDIR***************************************

NAME
     chdir, fchdir - change working directory

SYNOPSIS
     #include <unistd.h>

     int chdir(const char *path);

     int fchdir(int fildes);

DESCRIPTION
     The chdir() and fchdir() functions cause a directory pointed
     to  by  path  or fildes to become the current working direc-
     tory.  The starting point for path searches for  path  names
     not  beginning  with  / (slash). The path argument points to
     the path name of a directory. The fildes argument is an open
     file descriptor of a directory.

     For a directory to become the current directory,  a  process
     must have execute (search) access to the directory.

RETURN VALUES
     Upon successful completion, 0 is returned. Otherwise, -1  is
     returned,  the  current  working directory is unchanged, and
     errno is set to indicate the error.


*****************************GETENV**************************************


NAME
     getenv - return value for environment name

SYNOPSIS
     #include <stdlib.h>

     char *getenv(const char *name);

DESCRIPTION
     The getenv() function searches  the  environment  list  (see
     environ(5))  for a string of the form name=value and, if the
     string is present, returns a pointer to  the  value  in  the
     current environment.

RETURN VALUES
     If successful, getenv() returns a pointer to  the  value  in
     the  current  environment;  otherwise,  it  returns  a  null
     pointer.

USAGE
     The getenv() function can  be  safely  called  from  a  mul-
     tithreaded  application.   Care must be exercised when using
     both getenv() and  putenv(3C) in  a  multithreaded  applica-
     tion.   These  functions  examine and modify the environment
     list, which is shared by all  threads  in  an   application.
     The  system prevents the list from being accessed simultane-
     ously by two  different  threads.   It  does  not,  however,
     prevent two threads from successively accessing the environ-
     ment list using  getenv() or putenv(3C).

*****************************EXIT*****************************************

NAME
     exit, _exithandle - terminate process

SYNOPSIS
     #include <stdlib.h>

     void exit(int status);

     void _exithandle(void);

DESCRIPTION
     The exit() function terminates a process  by  calling  first
     _exithandle() and then _exit() (see exit(2)).

     The  _exithandle() function calls any  functions  registered
     through  the  atexit(3C)  function  in  the reverse order of
     their  registration.  This  action  includes  executing  all
     finalization  code  from  the  .fini sections of all objects
     that are part of the process.

     The _exithandle() function is intended  for  use  only  with
     _exit(),  and  allows  for  specialized  processing  such as
     dldump(3C) to be performed. Normal process execution  should
     not be continued after a call to _exithandle() has occurred,
     as internal data structures may have been torn down  due  to
     atexit() or .fini processing.

     The symbols EXIT_SUCCESS and EXIT_FAILURE are defined in the
     header  <stdlib.h> and may be used as the value of status to
     indicate successful  or  unsuccessful  termination,  respec-
     tively.

*****************************FORK*****************************************


NAME
     fork, fork1, forkall - create a new process

SYNOPSIS
     #include <sys/types.h>
     #include <unistd.h>

     pid_t fork(void);

     pid_t fork1(void);

     pid_t forkall(void);

DESCRIPTION
     The fork(), fork1(), and forkall() functions  create  a  new
     process.  The  address  space of the new process (child pro-
     cess) is an exact copy of the address space of  the  calling
     process  (parent  process).  The  child process inherits the
     following attributes from the parent process:

       o  real user ID, real group ID, effective user ID,  effec-
          tive group ID

       o  environment

       o  open file descriptors

       o  close-on-exec flags (see exec(2))

       o  signal handling settings (that  is,  SIG_DFL,  SIG_IGN,
          SIG_HOLD, function address)

*****************************OPEN****************************************


NAME
     open, openat - open a file

SYNOPSIS
     #include <sys/types.h>
     #include <sys/stat.h>
     #include <fcntl.h>

     int open(const char *path, int oflag, /* mode_t mode */);


     int openat(int fildes, const char *path, int oflag,
         /* mode_t mode */);


DESCRIPTION
     The open() function establishes  the  connection  between  a
     file and a file descriptor. It creates an open file descrip-
     tion that refers to a file and a file descriptor that refers
     to  that  open file description. The file descriptor is used
     by other I/O functions to refer to that file. The path argu-
     ment points to a pathname naming the file.

     The openat() function is identical to  the  open()  function
     except that the path argument is interpreted relative to the
     starting point implied by the fildes argument. If the fildes
     argument  has  the  special  value AT_FDCWD, a relative path
     argument will be resolved relative to  the  current  working
     directory.  If  the  path  argument  is absolute, the fildes
     argument is ignored.

     The open() function returns a file descriptor for the  named
     file  that  is the lowest file descriptor not currently open
     for that process. The open  file  description  is  new,  and
     therefore  the  file  descriptor  does not share it with any
     other process in the system. The FD_CLOEXEC file  descriptor
     flag associated with the new file descriptor is cleared.

     The file offset used to mark the current position within the
     file is set to the beginning of the file.

     The file status flags and file access modes of the open file
     description  are  set  according  to the value of oflag. The
     mode argument is used only when O_CREAT  is  specified  (see
     below.)

     Values for oflag are constructed by  a  bitwise-inclusive-OR
     of  flags  from  the  following  list, defined in <fcntl.h>.
     Applications must specify exactly one  of  the  first  three
     values (file access modes) below in the value of oflag:
     O_RDONLY    Open for reading only.


     O_WRONLY    Open for writing only.


     O_RDWR      Open for reading  and  writing.  The  result  is
                 undefined if this flag is applied to a FIFO.


     Any combination of the following may be used:

     O_APPEND

         If set, the file offset is set to the end  of  the  file
         prior to each write.


     O_CREAT

         Create the file if it does not exist. This flag requires
         that the mode argument be specified.

         If the file exists, this flag has no  effect  except  as
         noted  under  O_EXCL  below.   Otherwise,  the  file  is
         created with the user ID of the file set to  the  effec-
         tive user ID of the process. The group ID of the file is
         set to the effective group IDs of the process, or if the
         S_ISGID bit is set in the directory in which the file is
         being created, the file's group ID is set to  the  group
         ID  of its parent directory.  If the group ID of the new
         file does not match the effective group ID or one of the
         supplementary  groups  IDs,  the S_ISGID bit is cleared.
         The access permission bits  (see  <sys/stat.h>)  of  the
         file mode are set to the value of mode, modified as fol-
         lows (see creat(2)): a bitwise-AND is performed  on  the
         file-mode bits and the corresponding bits in the comple-
         ment of the process's file mode creation mask. Thus, all
         bits  set  in the process's file mode creation mask (see
         umask(2)) are correspondingly cleared in the file's per-
         mission  mask. The "save text image after execution bit"
         of the mode is cleared (see chmod(2)). O_SYNC Write  I/O
         operations on the file descriptor complete as defined by
         synchronized  I/O  file   integrity   completion    (see
         fcntl.h(3HEAD)  definition  of  O_SYNC.) When bits other
         than the file permission bits are  set,  the  effect  is
         unspecified.  The  mode argument does not affect whether
         the file is open for reading, writing or for both.


     O_DSYNC




SunOS 5.10           Last change: 2 Jul 2004                    2






System Calls                                              open(2)



         Write I/O operations on the file descriptor complete  as
         defined by synchronized I/O data integrity completion.


     O_EXCL

         If O_CREAT and O_EXCL are set, open() fails if the  file
         exists.  The check for the existence of the file and the
         creation of the file if it does not exist is atomic with
         respect  to  other  threads  executing open() naming the
         same filename in the  same  directory  with  O_EXCL  and
         O_CREAT  set.  If  O_EXCL  and O_CREAT are set, and path
         names a symbolic link, open() fails and  sets  errno  to
         EEXIST, regardless of the contents of the symbolic link.
         If O_EXCL is set and O_CREAT is not set, the  result  is
         undefined.


     O_LARGEFILE

         If set, the offset maximum in the open file  description
         is  the  largest value that can be represented correctly
         in an object of type off64_t.


     O_NOCTTY

         If set and path identifies  a  terminal  device,  open()
         does  not  cause  the terminal device to become the con-
         trolling terminal for the process.


     O_NOFOLLOW

         If the path names a symbolic link, open() fails and sets
         errno to ELOOP.


     O_NOLINKS

         If the link count of the named file is greater  than  1,
         open() fails and sets errno to EMLINK.


     O_NONBLOCK or O_NDELAY

         These flags can affect subsequent reads and writes  (see
         read(2)  and  write(2)). If both O_NDELAY and O_NONBLOCK
         are set, O_NONBLOCK takes precedence.

         When opening a FIFO with O_RDONLY or O_WRONLY set:




SunOS 5.10           Last change: 2 Jul 2004                    3






System Calls                                              open(2)



             o    If O_NONBLOCK or O_NDELAY is set, an open() for
                  reading  only returns without delay.  An open()
                  for writing only returns an error if no process
                  currently has the file open for reading.

             o    If O_NONBLOCK and O_NDELAY are clear, an open()
                  for  reading  only  blocks until a thread opens
                  the file for writing.  An  open()  for  writing
                  only  blocks  the calling thread until a thread
                  opens the file for reading.
         After both ends of a FIFO have been opened, there is  no
         guarantee   that   further   calls  to  open()  O_RDONLY
         (O_WRONLY) will synchronize with later calls  to  open()
         O_WRONLY  (O_RDONLY)  until  both  ends of the FIFO have
         been closed by all readers and writers.  Any data  writ-
         ten  into  a  FIFO will be lost if both ends of the FIFO
         are closed before the data is read.

         When opening a block special or character  special  file
         that supports non-blocking opens:

             o    If O_NONBLOCK or O_NDELAY is  set,  the  open()
                  function  returns without blocking for the dev-
                  ice  to  be  ready  or  available.   Subsequent
                  behavior of the device is device-specific.

             o    If  O_NONBLOCK  and  O_NDELAY  are  clear,  the
                  open() function blocks the calling thread until
                  the device is ready or available before return-
                  ing.
         Otherwise, the behavior of O_NONBLOCK  and  O_NDELAY  is
         unspecified.


     O_RSYNC

         Read I/O operations on the file descriptor  complete  at
         the  same level of integrity as specified by the O_DSYNC
         and O_SYNC flags. If both O_DSYNC and O_RSYNC are set in
         oflag,  all  I/O  operations on the file descriptor com-
         plete as defined by synchronized I/O data integrity com-
         pletion.   If  both O_SYNC and O_RSYNC are set in oflag,
         all I/O operations on the file  descriptor  complete  as
         defined by synchronized I/O file integrity completion.


     O_SYNC

         Write I/O operations on the file descriptor complete  as
         defined by synchronized I/O file integrity completion.





SunOS 5.10           Last change: 2 Jul 2004                    4






System Calls                                              open(2)



     O_TRUNC

         If the file exists and is a regular file, and  the  file
         is successfully opened O_RDWR or O_WRONLY, its length is
         truncated to 0 and the mode and owner are unchanged.  It
         has  no  effect on FIFO special files or terminal device
         files.   Its   effect   on   other   file    types    is
         implementation-dependent.  The  result  of using O_TRUNC
         with O_RDONLY is undefined.


     O_XATTR

         If set in openat(), a relative path argument  is  inter-
         preted  as  a  reference to an extended attribute of the
         file associated with the supplied file descriptor.  This
         flag  therefore  requires the presence of a legal fildes
         argument. If set in open(), the implied file  descriptor
         is  that  for  the  current  working directory. Extended
         attributes must be referenced with a relative path; pro-
         viding  an absolute path results in a normal file refer-
         ence.


     If O_CREAT is set and the file  did  not  previously  exist,
     upon  successful  completion,  open()  marks  for update the
     st_atime, st_ctime, and st_mtime fields of the file and  the
     st_ctime and st_mtime fields of the parent directory.

     If O_TRUNC is set and the file did  previously  exist,  upon
     successful  completion, open() marks for update the st_ctime
     and st_mtime fields of the file.

     If both the O_SYNC and O_DSYNC flags are set, the effect  is
     as if only the O_SYNC flag was set.

     If path refers to a STREAMS file, oflag may  be  constructed
     from  O_NONBLOCK  or  O_NODELAY  OR-ed with either O_RDONLY,
     O_WRONLY, or O_RDWR.  Other flag values are  not  applicable
     to  STREAMS  devices and have no effect on them.  The values
     O_NONBLOCK and O_NODELAY affect  the  operation  of  STREAMS
     drivers  and  certain  functions  (see  read(2),  getmsg(2),
     putmsg(2), and write(2)) applied to file descriptors associ-
     ated with STREAMS files.  For STREAMS drivers, the implemen-
     tation of O_NONBLOCK and O_NODELAY is device-specific.

     When open() is invoked to  open  a  named  stream,  and  the
     connld  module (see connld(7M)) has been pushed on the pipe,
     open()  blocks  until  the  server  process  has  issued  an
     I_RECVFD  ioctl()  (see  streamio(7I))  to  receive the file
     descriptor.




SunOS 5.10           Last change: 2 Jul 2004                    5






System Calls                                              open(2)



     If path names the master side of a  pseudo-terminal  device,
     then  it  is unspecified whether open() locks the slave side
     so that it cannot be  opened.   Portable  applications  must
     call unlockpt(3C) before opening the slave side.

     If path is a symbolic link and O_CREAT and O_EXCL  are  set,
     the link is not followed.

     Certain flag values can be set following open() as described
     in fcntl(2).

     The largest value that can be represented  correctly  in  an
     object of type off_t is established as the offset maximum in
     the open file description.

RETURN VALUES
     Upon successful completion, the open()  function  opens  the
     file  and  return  a  non-negative  integer representing the
     lowest numbered unused file  descriptor.  Otherwise,  -1  is
     returned,  errno  is set to indicate the error, and no files
     are created or modified.

ERRORS
     The open() and openat() functions will fail if:

     EACCES          Search permission is denied on  a  component
                     of the path prefix.

                     The file exists and the  permissions  speci-
                     fied by oflag are denied.

                     The file does not exist and write permission
                     is  denied  for  the parent directory of the
                     file to be created.

                     O_TRUNC is specified and write permission is
                     denied.

                     The {PRIV_FILE_DAC_SEARCH} privilege  allows
                     processes  to  search directories regardless
                     of        permission        bits.        The
                     {PRIV_FILE_DAC_WRITE}    privilege    allows
                     processes to open files for writing  regard-
                     less  of  permission bits. See privileges(5)
                     for  special  considerations  when   opening
                     files  owned  by  UID  0  for  writing.  The
                     {PRIV_FILE_DAC_READ}    privilege     allows
                     processes  to open files for reading regard-
                     less of permission bits.






SunOS 5.10           Last change: 2 Jul 2004                    6






System Calls                                              open(2)



     EBADF           The file descriptor provided to openat()  is
                     invalid.


     EDQUOT          The file does not exist, O_CREAT  is  speci-
                     fied, and either the directory where the new
                     file  entry  is  being  placed   cannot   be
                     extended  because  the  user's quota of disk
                     blocks  on  that  file   system   has   been
                     exhausted,  or the user's quota of inodes on
                     the file system  where  the  file  is  being
                     created has been exhausted.


     EEXIST          The O_CREAT and O_EXCL flags are set and the
                     named file exists.


     EINTR           A signal was caught during open().


     EFAULT          The  path  argument  points  to  an  illegal
                     address.


     EINVAL          The system does not support synchronized I/O
                     for  this file, or the O_XATTR flag was sup-
                     plied and the underlying  file  system  does
                     not support extended file attributes.


     EIO             The path argument names a STREAMS file and a
                     hangup or error occurred during the open().


     EISDIR          The named file  is  a  directory  and  oflag
                     includes O_WRONLY or O_RDWR.


     ELOOP           Too many symbolic links were encountered  in
                     resolving path.

                     A loop exists in symbolic links  encountered
                     during resolution of the path argument.

                     The O_NOFOLLOW flag is  set  and  the  final
                     component of path is a symbolic link.


     EMFILE          There are currently {OPEN_MAX} file descrip-
                     tors open in the calling process.




SunOS 5.10           Last change: 2 Jul 2004                    7






System Calls                                              open(2)



     EMLINK          The O_NOLINKS flag is set and the named file
                     has a link count greater than 1.


     EMULTIHOP       Components of path require hopping to multi-
                     ple remote machines and the file system does
                     not allow it.


     ENAMETOOLONG    The length  of  the  path  argument  exceeds
                     {PATH_MAX} or a pathname component is longer
                     than {NAME_MAX}.


     ENFILE          The maximum allowable  number  of  files  is
                     currently open in the system.


     ENOENT          The O_CREAT flag is not set  and  the  named
                     file  does not exist; or the O_CREAT flag is
                     set and either  the  path  prefix  does  not
                     exist  or  the  path  argument  points to an
                     empty string.


     ENOLINK         The  path  argument  points  to   a   remote
                     machine,  and the link to that machine is no
                     longer active.


     ENOSR           The path argument names a STREAMS-based file
                     and  the  system  is  unable  to  allocate a
                     STREAM.


     ENOSPC          The directory or file system that would con-
                     tain  the  new  file cannot be expanded, the
                     file does not exist, and O_CREAT  is  speci-
                     fied.


     ENOSYS          The device specified by path does  not  sup-
                     port the open operation.


     ENOTDIR         A component of the  path  prefix  is  not  a
                     directory or a relative path was supplied to
                     openat(), the O_XATTR flag was not supplied,
                     and  the file descriptor does not refer to a
                     directory.





SunOS 5.10           Last change: 2 Jul 2004                    8






System Calls                                              open(2)



     ENXIO           The O_NONBLOCK flag is set, the  named  file
                     is  a FIFO, the O_WRONLY flag is set, and no
                     process has the file open  for  reading;  or
                     the  named  file  is  a character special or
                     block special file and the device associated
                     with this special file does not exist.


     EOPNOTSUPP      An attempt was made  to  open  a  path  that
                     corresponds to a AF_UNIX socket.


     EOVERFLOW       The named file is a regular file and  either
                     O_LARGEFILE  is  not set and the size of the
                     file cannot be represented correctly  in  an
                     object  of  type off_t or O_LARGEFILE is set
                     and  the  size  of  the   file   cannot   be
                     represented  correctly  in an object of type
                     off64_t.


     EROFS           The named file resides on a  read-only  file
                     system  and either O_WRONLY, O_RDWR, O_CREAT
                     (if file does not exist), or O_TRUNC is  set
                     in the oflag argument.


     The openat() function will fail if:

     EBADF    The fildes  argument  is  not  a  valid  open  file
              descriptor or is not AT_FTCWD.


     The open() function may fail if:

     EAGAIN          The path argument names the slave side of  a
                     pseudo-terminal device that is locked.


     EINVAL          The value  of  the  oflag  argument  is  not
                     valid.


     ENAMETOOLONG    Pathname resolution of a symbolic link  pro-
                     duced  an  intermediate  result whose length
                     exceeds {PATH_MAX}.


     ENOMEM          The path argument names a STREAMS  file  and
                     the system is unable to allocate resources.





SunOS 5.10           Last change: 2 Jul 2004                    9






System Calls                                              open(2)



     ETXTBSY         The file is a pure procedure  (shared  text)
                     file  that  is  being  executed and oflag is
                     O_WRONLY or O_RDWR.


EXAMPLES
     Example 1 Open a file for writing by the owner.

     The following example opens the file  /tmp/file,  either  by
     creating  it  if it does not already exist, or by truncating
     its length to 0 if it does exist. If the call creates a  new
     file,  the  access  permission  bits in the file mode of the
     file are set to permit reading and writing by the owner, and
     to permit reading only by group members and others.


     If the call to open() is successful, the file is opened  for
     writing.


       #include <fcntl.h>
       ...
       int fd;
       mode_t mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH;
       char *filename = "/tmp/file";
       ...
       fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, mode);
       ...


     Example 2 Open a file using an existence check.

     The following example uses the open()  function  to  try  to
     create  the LOCKFILE file and open it for writing. Since the
     open() function specifies the O_EXCL flag, the call fails if
     the  file  already  exists.  In  that  case, the application
     assumes that someone else is updating the password file  and
     exits.


       #include <fcntl.h>
       #include <stdio.h>
       #include <stdlib.h>
       #define LOCKFILE "/etc/ptmp"
       ...
       int pfd; /* Integer for file descriptor returned by open() call. */
       ...
       if ((pfd = open(LOCKFILE, O_WRONLY | O_CREAT | O_EXCL,
              S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
       {
              fprintf(stderr, "Cannot open /etc/ptmp. Try again later.\n");
              exit(1);



SunOS 5.10           Last change: 2 Jul 2004                   10






System Calls                                              open(2)



       }
       ...


     Example 3 Open a file for writing.

     The following example opens a file for writing, creating the
     file  if  it does not already exist. If the file does exist,
     the system truncates the file to zero bytes.


       #include <fcntl.h>
       #include <stdio.h>
       #include <stdlib.h>
       #define LOCKFILE "/etc/ptmp"
       ...
       int pfd;
       char filename[PATH_MAX+1];
       ...
       if ((pfd = open(filename, O_WRONLY | O_CREAT | O_TRUNC,
              S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) == -1)
       {
              perror("Cannot open output file\n"); exit(1);
       }
       ...


USAGE
     The open() function has a transitional interface for  64-bit
     file  offsets.   See  lf64(5).  Note  that using open64() is
     equivalent to using open() with O_LARGEFILE set in oflag.

ATTRIBUTES

******************************PERROR************************************

NAME
     perror, errno - print system error messages

SYNOPSIS
     #include <stdio.h>

     void perror(const char *s)


     #include <errno.h>

     int errno;


DESCRIPTION
     The perror() function produces a  message  on  the  standard
     error  output  (file descriptor 2) describing the last error
     encountered during a call to a system or  library  function.
     The  argument string s is printed, followed by a colon and a
     blank, followed by the message and a NEWLINE character.   If
     s is a null pointer or points to a null string, the colon is
     not printed. The argument string should include the name  of
     the  program  that  incurred  the error. The error number is
     taken from the external variable errno, which  is  set  when
     errors  occur  but  not cleared when non-erroneous calls are
     made. See intro(2).


     In the case of multithreaded applications,  the  -mt  option
     must  be  specified  on the command line at compilation time
     (see threads(5)). When the -mt option  is  specified,  errno
     becomes  a  macro  that  enables each thread to have its own
     errno. This errno macro can be used on either  side  of  the
     assignment as though it were a variable.

USAGE
     Messages printed  from  this  function  are  in  the  native
     language  specified by the LC_MESSAGES locale category.  See
     setlocale(3C).


******************************WAIT**************************************

NAME
     wait - wait for child process to stop or terminate

SYNOPSIS
     #include <sys/types.h>
     #include <sys/wait.h>

     pid_t wait(int *stat_loc);

DESCRIPTION
     The wait() function will suspend execution  of  the  calling
     thread  until  status  information for one of its terminated
     child processes is available, or until delivery of a  signal
     whose action is either to execute a signal-catching function
     or to terminate the process. If  more  than  one  thread  is
     suspended in wait(), waitpid(3C), or waitid(2) awaiting ter-
     mination of the same process, exactly one thread will return
     the  process status at the time of the target process termi-
     nation. If status information is available prior to the call
     to wait(), return will be immediate.

     If wait() returns because the status of a child  process  is
     available,  it  returns the process ID of the child process.
     If the  calling  process  specified  a  non-zero  value  for
     stat_loc,  the  status of the child process is stored in the
     location  pointed  to  by  stat_loc.  That  status  can   be
     evaluated  with  the  macros  described on the wait.h(3HEAD)
     manual page.

     In the  following,  status  is  the  object  pointed  to  by
     stat_loc:

       o  If the child process terminated due to an _exit() call,
          the  low  order 8 bits of status will be 0 and the high
          order 8 bits will contain the low order 7 bits  of  the
          argument  that the child process passed to _exit(); see
          exit(2).

       o  If the child process terminated due to  a  signal,  the
          high order 8 bits of status will be 0 and the low order
          7bits will contain the number of the signal that caused
          the  termination.  In  addition, if  WCOREFLG is set, a
          "core   image"   will   have   been    produced;    see
          signal.h(3HEAD) and wait.h(3HEAD).


     One instance of a SIGCHLD signal is queued  for  each  child
     process  whose status has changed. If wait() returns because
     the status of a child  process  is  available,  any  pending
     SIGCHLD  signal associated with the process ID of that child
     process is discarded.  Any  other  pending  SIGCHLD  signals
     remain pending.



SunOS 5.10           Last change: 9 Jun 2004                    1






Standard C Library Functions                             wait(3C)



     If the calling process has SA_NOCLDWAIT set or  has  SIGCHLD
     set  to  SIG_IGN,  and  the process has no unwaited children
     that were transformed into zombie processes, it  will  block
     until  all  of  its children terminate, and wait() will fail
     and set errno to ECHILD.

     If a parent process terminates without waiting for its child
     processes  to terminate, the parent process ID of each child
     process is set to 1, with the initialization process  inher-
     iting the child processes; see intro(2).

RETURN VALUES
     When wait() returns due to a terminated child  process,  the
     process  ID of the child is returned to the calling process.
     Otherwise, -1 is returned and errno is set to  indicate  the
     error.

ERRORS
     The wait() function will fail if:

     ECHILD          The  calling   process   has   no   existing
                     unwaited-for child processes.



     EINTR           The function was interrupted by a signal.



USAGE
     Since wait() blocks on a stopped child,  a  calling  process
     wanting  to see the return results of such a call should use
     waitpid(3C) or waitid(2) instead of wait(). The wait() func-
     tion is implemented as a call to waitpid(-1, stat_loc, 0).


******************************STAT****************************************

NAME
     stat, lstat, fstat, fstatat - get file status

SYNOPSIS
     #include <fcntl.h>
     #include <sys/types.h>
     #include <sys/stat.h>

     int stat(const char *restrict path, struct stat *restrict buf);


     int lstat(const char *restrict path, struct stat *restrict buf);


     int fstat(int fildes, struct stat *buf);


     int fstatat(int fildes, const char *path, struct stat *buf,
         int flag);


DESCRIPTION
     The stat()  function  obtains  information  about  the  file
     pointed  to  by  path. Read, write, or execute permission of
     the named file is not required, but all  directories  listed
     in the path name leading to the file must be searchable.

     The lstat() function  obtains  file  attributes  similar  to
     stat(),  except  when  the named file is a symbolic link; in
     that case lstat() returns information about the link,  while
     stat()  returns  information  about the file the link refer-
     ences.

     The fstat() function obtains information about an open  file
     known  by  the  file descriptor fildes, obtained from a suc-
     cessful open(2),  creat(2),  dup(2),  fcntl(2),  or  pipe(2)
     function.  If  fildes references a shared memory object, the
     system updates in the stat structure pointed to by  the  buf
     argument  only  the  st_uid,  st_gid,  st_size,  and st_mode
     fields, and only the  S_IRUSR,  S_IWUSR,  S_IRGRP,  S_IWGRP,
     S_IROTH, and S_IWOTH file permission bits need be valid. The
     system can update other fields and flags. The fstat()  func-
     tion  updates any pending time-related fields before writing
     to the stat structure.

     The fstatat() function obtains file  attributes  similar  to
     the  stat(),  lstat(),  and  fstat() functions.  If the path
     argument is a relative path, it is resolved relative to  the
     fildes  argument  rather than the current working directory.
     If path is absolute, the fildes argument is unused.  If  the
     fildes  argument  has  the  special value AT_FDCWD, relative
     paths are resolved from the current working  directory.   If



SunOS 5.10          Last change: 13 Feb 2007                    1






System Calls                                              stat(2)



     the  flag  argument  is  AT_SYMLINK_NOFOLLOW,  the  function
     behaves like lstat() and does not automatically follow  sym-
     bolic links. See fsattr(5).

     The buf argument is a pointer to a stat structure into which
     information  is placed concerning the file. A stat structure
     includes the following members:

       mode_t   st_mode;          /* File mode (see mknod(2)) */
       ino_t    st_ino;           /* Inode number */
       dev_t    st_dev;           /* ID of device containing */
                                 /* a directory entry for this file */
       dev_t    st_rdev;          /* ID of device */
                                 /* This entry is defined only for */
                                 /* char special or block special files */
       nlink_t  st_nlink;         /* Number of links */
       uid_t    st_uid;           /* User ID of the file's owner */
       gid_t    st_gid;           /* Group ID of the file's group */
       off_t    st_size;          /* File size in bytes */
       time_t   st_atime;         /* Time of last access */
       time_t   st_mtime;         /* Time of last data modification */
       time_t   st_ctime;         /* Time of last file status change */
                                 /* Times measured in seconds since */
                                 /* 00:00:00 UTC, Jan. 1, 1970 */
       long     st_blksize;       /* Preferred I/O block size */
       blkcnt_t st_blocks;        /* Number of 512 byte blocks allocated*/
       char     st_fstype[_ST_FSTYPSZ];
                                 /* Null-terminated type of filesystem */


     Descriptions of structure members are as follows:

     st_mode       The mode of the  file  as  described  for  the
                   mknod()  function.  In  addition  to the modes
                   described on the  mknod(2)  manual  page,  the
                   mode  of  a  file  can also be S_IFSOCK if the
                   file is a socket, S_IFDOOR if the  file  is  a
                   door,  S_IFPORT  if the file is an event port,
                   or S_IFLNK if the file  is  a  symbolic  link.
                   S_IFLNK  can  be returned either by lstat() or
                   by fstat() when the  AT_SYMLINK_NOFOLLOW  flag
                   is set.


     st_ino        This field uniquely identifies the file  in  a
                   given   file  system.  The  pair   st_ino  and
                   st_dev uniquely identifies regular files.


     st_dev        This field uniquely identifies the file system
                   that  contains the file. Its value may be used
                   as input to the ustat() function to  determine



SunOS 5.10          Last change: 13 Feb 2007                    2






System Calls                                              stat(2)



                   more  information  about  this file system. No
                   other meaning is associated with this value.


     st_rdev       This field should be used only by  administra-
                   tive commands. It is valid only for block spe-
                   cial or character special files and  only  has
                   meaning  on the system where the file was con-
                   figured.


     st_nlink      This field should be used only by  administra-
                   tive commands.


     st_uid        The user ID of the file's owner.


     st_gid        The group ID of the file's group.


     st_size       For regular files, this is the address of  the
                   end  of the file. For block special or charac-
                   ter special, this is  not  defined.  See  also
                   pipe(2).


     st_atime      Time when file data was last accessed. Some of
                   the  functions  that  change  this member are:
                   creat(),  mknod(),   pipe(),   utime(2),   and
                   read(2).


     st_mtime      Time when data was last modified. Some of  the
                   functions   that   change   this  member  are:
                   creat(),   mknod(),   pipe(),   utime(),   and
                   write(2).


     st_ctime      Time when file status was last  changed.  Some
                   of  the functions that change this member are:
                   chmod(2),   chown(2),    creat(2),    link(2),
                   mknod(2),   pipe(2),   rename(2),   unlink(2),
                   utime(2), and write(2).


     st_blksize    A hint as to the  "best"  unit  size  for  I/O
                   operations.  This  field  is  not  defined for
                   block special or character special files.






SunOS 5.10          Last change: 13 Feb 2007                    3






System Calls                                              stat(2)



     st_blocks     The total number of physical  blocks  of  size
                   512  bytes  actually  allocated  on disk. This
                   field is not  defined  for  block  special  or
                   character special files.


     st_fstype     A null-teminated string that uniquely  identi-
                   fies  the type of the filesystem that contains
                   the file.


RETURN VALUES
     Upon successful completion, 0 is returned. Otherwise, -1  is
     returned and errno is set to indicate the error.

ERRORS
     The stat(), fstat(), lstat(), and fstatat()  functions  will
     fail if:

     EIO          An error occurred while reading from  the  file
                  system.


     EOVERFLOW    The file size in bytes or the number of  blocks
                  allocated to the file or the file serial number
                  cannot be represented correctly in  the  struc-
                  ture pointed to by buf.


     The stat(), lstat(), and fstatat() functions will fail if:

     EACCES          Search permission is denied for a  component
                     of the path prefix.


     EFAULT          The  buf or path argument points to an ille-
                     gal address.


     EINTR           A signal was caught during the execution  of
                     the  stat() or lstat() function.


     ELOOP           A loop exists in symbolic links  encountered
                     during the resolution of the path argument.


     ENAMETOOLONG    The length  of  the  path  argument  exceeds
                     {PATH_MAX},  or  the  length  of a path com-
                     ponent     exceeds     {NAME_MAX}      while
                     _POSIX_NO_TRUNC is in effect.




SunOS 5.10          Last change: 13 Feb 2007                    4






System Calls                                              stat(2)



     ENOENT          A component of path does not name an  exist-
                     ing file or path is an empty string.


     ENOLINK         The path argument points to a remote machine
                     and  the  link  to that machine is no longer
                     active.


     ENOTDIR         A component of the  path  prefix  is  not  a
                     directory,  or  the fildes argument does not
                     refer to a  valid  directory  when  given  a
                     non-null relative path.


     The fstat() and fstatat() functions will fail if:

     EBADF      The fildes argument is  not  a  valid  open  file
                descriptor.  The fildes argument to fstatat() can
                also have the valid value of AT_FDCWD.


     EFAULT     The buf argument points to an illegal address.


     EINTR      A signal was caught during the execution  of  the
                fstat() function.


     ENOLINK    The fildes argument points to  a  remote  machine
                and the link to that machine is no longer active.


     The stat(), fstat(), and lstat() functions may fail if:

     EOVERFLOW    One of the members is too large to store in the
                  stat structure pointed to by buf.


     The stat() and lstat() functions may fail if:

     ELOOP           More than {SYMLOOP_MAX} symbolic links  were
                     encountered  during  the  resolution  of the
                     path argument.


     ENAMETOOLONG    As a result of encountering a symbolic  link
                     in   resolution  of  thepath  argument,  the
                     length of the substituted  pathname  strings
                     exceeds {PATH_MAX}.





SunOS 5.10          Last change: 13 Feb 2007                    5






System Calls                                              stat(2)



EXAMPLES
     Example 1 Use stat() to obtain file status information.

     The following example shows how to obtain file status infor-
     mation  for a file named /home/cnd/mod1. The structure vari-
     able buffer is defined for the stat structure.


       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>
       struct stat buffer;
       int         status;
       ...
       status = stat("/home/cnd/mod1", &buffer);


     Example 2 Use stat() to get directory information.

     The following example fragment gets status  information  for
     each  entry  in a directory. The call to the stat() function
     stores file information in the stat structure pointed to  by
     statbuf.  The  lines  that follow the stat() call format the
     fields in the stat structure for presentation to the user of
     the program.


       #include <sys/types.h>
       #include <sys/stat.h>
       #include <dirent.h>
       #include <pwd.h>
       #include <grp.h>
       #include <time.h>
       #include <locale.h>
       #include <langinfo.h>
       #include <stdio.h>
       #include <stdint.h>
       struct dirent *dp;
       struct stat   statbuf;
       struct passwd *pwd;
       struct group  *grp;
       struct tm     *tm;
       char          datestring[256];
       ...
       /* Loop through directory entries */
       while ((dp = readdir(dir)) != NULL) {
          /* Get entry's information. */
          if (stat(dp->d_name, &statbuf) == -1)
          continue;

           /* Print out type, permissions, and number of links. */
           printf("%10.10s", sperm (statbuf.st_mode));



SunOS 5.10          Last change: 13 Feb 2007                    6






System Calls                                              stat(2)



           printf("%4d", statbuf.st_nlink);

           /* Print out owners name if it is found using getpwuid(). */
           if ((pwd = getpwuid(statbuf.st_uid)) != NULL)
              printf(" %-8.8s", pwd->pw_name);
           else
              printf(" %-8d", statbuf.st_uid);

           /* Print out group name if it's found using getgrgid(). */
           if ((grp = getgrgid(statbuf.st_gid)) != NULL)
              printf(" %-8.8s", grp->gr_name);
           else
              printf(" %-8d", statbuf.st_gid);

           /* Print size of file. */
           printf(" %9jd", (intmax_t)statbuf.st_size);
           tm = localtime(&statbuf.st_mtime);

           /* Get localized date string. */
           strftime(datestring, sizeof(datestring), nl_langinfo(D_T_FMT), tm);

           printf(" %s %s\n", datestring, dp->d_name);
       }


     Example 3 Use fstat() to obtain file status information.

     The following example shows how to obtain file status infor-
     mation  for a file named /home/cnd/mod1. The structure vari-
     able  buffer  is  defined  for  the  stat   structure.   The
     /home/cnd/mod1 file is opened with read/write privileges and
     is passed to the open file descriptor fildes.


       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>
       struct stat buffer;
       int         status;
       ...
       fildes = open("/home/cnd/mod1", O_RDWR);
       status = fstat(fildes, &buffer);


     Example 4 Use lstat() to obtain symbolic link status  infor-
     mation.

     The following example shows how to obtain status information
     for  a  symbolic  link  named  /modules/pass1. The structure
     variable buffer is defined for the stat  structure.  If  the
     path argument specified the filename for the file pointed to
     by  the  symbolic  link  (/home/cnd/mod1),  the  results  of



SunOS 5.10          Last change: 13 Feb 2007                    7






System Calls                                              stat(2)



     calling  the function would be the same as those returned by
     a call to the stat() function.


       #include <sys/stat.h>
       struct stat buffer;
       int         status;
       ...
       status = lstat("/modules/pass1", &buffer);


USAGE
     If chmod() or fchmod() is used  to  change  the  file  group
     owner  permissions  on  a file with non-trivial ACL entries,
     only the ACL mask is set to  the  new  permissions  and  the
     group  owner  permission  bits  in  the  file's  mode  field
     (defined in mknod(2))  are  unchanged.   A  non-trivial  ACL
     entry  is  one  whose  meaning  cannot be represented in the
     file's mode field alone. The new ACL mask permissions  might
     change  the  effective  permissions for additional users and
     groups that have ACL entries on the file.

     The stat(), fstat(), and lstat() functions have transitional
     interfaces for 64-bit file offsets.  See lf64(5).




******************************PIPE****************************************
NAME
     pipe - create an interprocess channel

SYNOPSIS
     #include <unistd.h>

     int pipe(int fildes[2]);

DESCRIPTION
     The pipe() function creates an I/O mechanism called  a  pipe
     and  returns  two file descriptors, fildes[0] and fildes[1].
     The  files  associated  with  fildes[0]  and  fildes[1]  are
     streams  and  are  both opened for reading and writing.  The
     O_NDELAY, O_NONBLOCK, and FD_CLOEXEC flags  are  cleared  on
     both  file descriptors. The fcntl(2) function can be used to
     set these flags.

     A read from fildes[0] accesses the data written to fildes[1]
     on  a  first-in-first-out  (FIFO)  basis  and  a  read  from
     fildes[1] accesses the data written to fildes[0] also  on  a
     FIFO basis.

     Upon successful  completion  pipe()  marks  for  update  the
     st_atime, st_ctime, and st_mtime fields of the pipe.

RETURN VALUES
     Upon successful completion, 0 is returned. Otherwise, -1  is
     returned and errno is set to indicate the error.

ERRORS
     The pipe() function will fail if:

     EMFILE          More than {OPEN_MAX}  file  descriptors  are
                     already in use by this process.



     ENFILE          The number of simultaneously open  files  in
                     the  system  would  exceed  a system-imposed
                     limit.



******************************FFLUSH***************************************

NAME
     fflush - flush a stream

SYNOPSIS
     #include <stdio.h>

     int fflush(FILE *stream);

DESCRIPTION
     If stream points to an output stream or an update stream  in
     which  the  most  recent  operation  was not input, fflush()
     causes any unwritten data for that stream to be  written  to
     the file, and the st_ctime and st_mtime fields of the under-
     lying file are marked for update.

     If stream points to an input stream or an update stream into
     which  the  most  recent operation was input, that stream is
     flushed if it is seekable and is not already at end-of-file.
     Flushing  an  input  stream  discards any buffered input and
     adjusts the file pointer such that the next input  operation
     accesses  the  byte  after  the  last one read.  A stream is
     seekable if the underlying file is not a pipe, FIFO, socket,
     or TTY device.

     If stream is a null pointer, fflush() performs this flushing
     action  on  all  streams  for  which the behavior is defined
     above.

     An input stream, seekable or non-seekable, can be flushed by
     explicitly  calling fflush() with a non-null argument speci-
     fying that stream.

RETURN VALUES
     Upon successful completion, fflush() returns  0.  Otherwise,
     it returns EOF and sets errno to indicate the error.

ERRORS
     The fflush() function will fail if:

     EAGAIN          The O_NONBLOCK flag  is  set  for  the  file
                     descriptor underlying stream and the process
                     would be delayed in the write operation.



     EBADF           The file descriptor underlying stream is not
                     valid.



     EFBIG           An attempt was made to  write  a  file  that
                     exceeds   the   maximum  file  size  or  the



SunOS 5.10           Last change: 1 Nov 2003                    1






Standard C Library Functions                           fflush(3C)



                     process's file size limit; or the file is  a
                     regular  file  and  an  attempt  was made to
                     write at or beyond the offset maximum  asso-
                     ciated with the corresponding stream.



     EINTR           The fflush() function was interrupted  by  a
                     signal.



     EIO             The process is a member of a background pro-
                     cess  group  attempting to write to its con-
                     trolling terminal, TOSTOP is set,  the  pro-
                     cess   is   neither  ignoring  nor  blocking
                     SIGTTOU, and the process group of  the  pro-
                     cess is orphaned.



     ENOSPC          There was no free  space  remaining  on  the
                     device containing the file.



     EPIPE           An attempt is made to write  to  a  pipe  or
                     FIFO  that  is  not  open for reading by any
                     process. A SIGPIPE signal will also be  sent
                     to the calling process.



     The fflush() function may fail if:

     ENXIO           A request was made of a non-existent device,
                     or  the request was beyond the limits of the
                     device.

******************************SIGNAL***************************************


NAME
     signal, sigset, sighold,  sigrelse,  sigignore,  sigpause  -
     simplified signal management for application processes

SYNOPSIS
     #include <signal.h>

     void (*signal(int sig, void (*disp)(int)))(int);


     void (*sigset(int sig, void (*disp)(int)))(int);


     int sighold(int sig);


     int sigrelse(int sig);


     int sigignore(int sig);


     int sigpause(int sig);


DESCRIPTION
     These functions provide  simplified  signal  management  for
     application  processes.  See signal.h(3HEAD) for an explana-
     tion of general signal concepts.


     The signal() and sigset() functions modify  signal  disposi-
     tions.  The  sig argument specifies the signal, which may be
     any signal except SIGKILL and  SIGSTOP.  The  disp  argument
     specifies  the  signal's  disposition, which may be SIG_DFL,
     SIG_IGN, or the address of a signal handler. If signal()  is
     used,  disp  is  the address of a signal handler, and sig is
     not  SIGILL, SIGTRAP, or  SIGPWR, the system first sets  the
     signal's disposition to  SIG_DFL before executing the signal
     handler. If sigset() is used and disp is the  address  of  a
     signal handler, the system adds sig to the calling process's
     signal  mask before executing the signal handler;  when  the
     signal  handler  returns,  the  system  restores the calling
     process's signal mask to its state prior to the delivery  of
     the  signal.  In  addition,  if sigset() is used and disp is
     equal to  SIG_HOLD, sig is added to  the  calling  process's
     signal mask and the signal's disposition remains unchanged.


     The sighold() function adds sig  to  the  calling  process's
     signal mask.




SunOS 5.10           Last change: 6 Sep 2007                    1






Standard C Library Functions                           signal(3C)



     The  sigrelse()  function  removes  sig  from  the   calling
     process's signal mask.


     The sigignore() function sets  the  disposition  of  sig  to
     SIG_IGN.


     The  sigpause()  function  removes  sig  from  the   calling
     process's  signal  mask   and  suspends  the calling process
     until a signal is received.

RETURN VALUES
     Upon successful completion, signal()  returns  the  signal's
     previous  disposition.  Otherwise,  it  returns  SIG_ERR and
     sets errno to indicate the error.


     Upon successful completion, sigset() returns SIG_HOLD if the
     signal had been blocked or the signal's previous disposition
     if it had not been blocked. Otherwise, it  returns   SIG_ERR
     and sets errno to indicate the error.


     Upon successful completion,  sighold(),  sigrelse(),  sigig-
     nore(),  and  sigpause(),  return  0. Otherwise, they return
     -1 and set  errno to indicate the error.

ERRORS
     These functions fail if:

     EINTR     A signal was  caught  during  the  execution  sig-
               pause().


     EINVAL    The value of the sig argument is not a valid  sig-
               nal or is equal to  SIGKILL or  SIGSTOP.


USAGE
     The sighold() function used in conjunction  with  sigrelse()
     or  sigpause()  may be used to establish critical regions of
     code that require the delivery of a signal to be temporarily
     deferred.


     If signal() or sigset() is used to set   SIGCHLD's  disposi-
     tion  to a signal handler, SIGCHLD will not be sent when the
     calling process's children are stopped or continued.






SunOS 5.10           Last change: 6 Sep 2007                    2






Standard C Library Functions                           signal(3C)



     If any of the above functions  are  used  to  set  SIGCHLD's
     disposition   to   SIG_IGN,   the  calling  process's  child
     processes will not create zombie processes  when  they  ter-
     minate  (see  exit(2)).  If the calling process subsequently
     waits for its children, it blocks until all of its  children
     terminate;  it then returns -1 with errno set to ECHILD (see
     wait(3C) and waitid(2)).


     The system guarantees that if more than one instance of  the
     same  signal  is generated to a process, at least one signal
     will be received.  It does not guarantee  the  reception  of
     every generated signal.

******************************KILLPG************************************


NAME
     killpg - send signal to a process group

SYNOPSIS
     #include <signal.h>

     int killpg(pid_t pgrp, int sig);

DESCRIPTION
     The killpg() function sends the signal sig  to  the  process
     group pgrp. See signal.h(3HEAD) for a list of signals.

     The real or effective user ID of the  sending  process  must
     match  the  real  or saved set-user ID of the receiving pro-
     cess, unless the effective user ID of the sending process is
     the  privileged  user.  A  single  exception  is  the signal
     SIGCONT, which may always be sent to any descendant  of  the
     current process.

RETURN VALUES
     Upon successful completion, 0 is returned. Otherwise, -1  is
     returned and errno is set to indicate the error.

ERRORS
     The killpg() function will fail and no signal will  be  sent
     if:

     EINVAL          The sig  argument  is  not  a  valid  signal
                     number.



     EPERM           The effective user ID of the sending process
                     is not privileged user, and neither its real
                     nor effective user ID matches  the  real  or
                     saved set-user ID of one or more of the tar-
                     get processes.



     ESRCH           No processes were  found  in  the  specified
                     process group.

